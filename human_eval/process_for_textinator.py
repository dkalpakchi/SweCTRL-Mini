import os
import sys
import re
import json
import glob
import random
import argparse
from collections import defaultdict

import jsonlines as jsl

from control_codes import START_C_CODES, END_C_CODES


def remove_cc(text):
    for x in END_C_CODES.values():
        text = text.replace(x, "")

    for x in START_C_CODES.values():
        text = text.replace(x, "")
    
    return re.sub(" {2,}", " ", text).strip()


gpt3_prompt_templates = {
    "news": "Skriv en nyhetsartikel.\\",
    "wiki": "Skriv en artikel i Wikipedia.\\",
    "news_sport": "Skriv en nyhetsartikel om idrott.\\",
    "blogs": "Skriv ett blogginlägg.\\",
    "news_pressrelease": "Skriv ett pressmeddelande.\\",
    "ads": "Skriv en annons.\\",
    "news_opinion": "Skriv en insändare.\\",
    "news_culture": "Skriv en nyhetsartikel om kultur.\\",
    "admin": "Skriv en förvaltningstext.\\",
    "news_economy": "Skriv en nyhetsartikel om ekonomi.\\",
    "info_medical": "Skriv en informerande text om ett medicinskt ämne.\\",
    "info": "Skriv en informerande text.\\",
    "news_tech": "Skriv en nyhetsartikel om teknologi.\\",
    "review": "Skriv en recension.\\",
    "info_travel": "Skriv en informerande text om resor.\\",
    "news_lifestyle": "Skriv en nyhetsartikel om livstil.\\",
    "blogs_sport": "Skriv ett blogginlägg om idrott.\\",
    "info_lifestyle": "Skriv en informerande text om livstil.\\",
    "news_sustainability": "Skriv en nyhetsartikel om hållbarhet.\\",
    "news_travel": "Skriv en nyhetsartikel om resor.\\",
    "info_business": "Skriv en informerande text om affär.\\",
    "news_politics": "Skriv en nyhetsartikel om politik.\\",
    "news_science": "Skriv en nyhetsartikel om vetenskap.\\",
    "news_food": "Skriv en nyhetsartikel om mat.\\",
    "news_fashion": "Skriv en nyhetsartikel om mode.\\",
    "news_weather": "Skriv en nyhetsartikel om vädret.\\",
    "blogs_economy": "Skriv ett blogginlägg om ekonomi.\\"
}

def verbalize_prompt(cat, prompt):
    cat = cat.replace("/", "_")
    return '{} som börjar med "{}"'.format(
        gpt3_prompt_templates[cat].strip(".\\"),
        prompt
    )

if __name__ == '__main__':
    base_dir = os.path.dirname(os.path.realpath(__file__))

    gpt3_files = []#os.path.join(base_dir, "generated_1680293305.jsonl")]
    swectrl_files = glob.glob(os.path.join(base_dir, "generated_1_2786844", "*", "*.json"))

    data = defaultdict(lambda: defaultdict(list))

    for fname in swectrl_files:
        with open(fname) as f:
            res = json.load(f)
            cc, prompt = res["control"], res["prompt"]
            gen_args = res["gen_args"]
            # here prompt is already included in the text
            data[cc][prompt].append((
                gen_args,
                verbalize_prompt(cc, prompt),
                remove_cc(res['text'])
            ))

    # we pick only generations from GPT-3 for categories and prompts which have texts generated by SweCTRL
    for fname in gpt3_files:
        with jsl.open(fname) as f:
            for obj in f:
                cc = obj["cat"].replace("_", "/")
                prompt = obj["params"]["prompt"].replace(gpt3_prompt_templates[obj["cat"]], "").strip()
                if cc not in data: continue
                if prompt not in data[cc]: continue
                text = obj["res"]["choices"][0]["text"]
                if len(data[cc][prompt]) < 9:
                    data[cc][prompt].append((
                        "gpt-3",
                        verbalize_prompt(cc, prompt),
                        re.sub(" {2,}", " ", "{} {}".format(prompt, text))
                    ))

    tt_data = [[], []]
    tt_models = [[], []]

    cats = list(data.keys())
    N_cats = len(cats)

    part_id = 0
    for i, cat in enumerate(cats):
        if i == N_cats / 2:
            part_id += 1

        for prompt, gens in data[cat].items():
            random.shuffle(gens)
            
            for model, vprompt, gen in gens:
                tt_data[part_id].append({
                    "text": "{}\n!-^-!\n__Task:__{}".format(gen, vprompt)
                })
                tt_models[part_id].append(model)

    for i in range(len(tt_data)):
        with open(os.path.join(base_dir, "swectrl_aedata_p{}.json".format(i)), 'w') as f:
            json.dump(tt_data[i], f)
        with open(os.path.join(base_dir, "swectrl_aekey_p{}.json".format(i)), 'w') as f:
            json.dump(tt_models[i], f)


